\section{Συμπεράσματα/Μελλοντικές Βελτιώσεις}
Σε αυτό το κεφάλαιο παρουσιάζονται κάποια συμπεράσματα στα οποία φτάσαμε ύστερα από τη μελέτη που έγινε στα πλαίσια αυτής της εργασίας. Επίσης, αναφέρονται επιπλέον θέματα που θα μπορούσαν να είχαν μελετηθεί 
και πιθανές βελτιώσεις που θα μπορούσαμε να κάνουμε στην υπάρχουσα υλοποίηση.

\subsection{Υλοποίηση με Dynamic Time Warping}
Ένα από τα βασικά προβλήματα που αντιμετωπίσαμε ήταν ο μεγάλος χρόνος εκτέλεσης στο πειραματικό στάδιο. Το θετικό της επιλογής της Python σαν γλώσσα προγραμματισμού ήταν ότι μας βοήθησε στο να φτιάξουμε γρήγορα το λογισμικό μας, και το ότι υπήρχαν πολλές διαθέσιμες βιβλιοθήκες για το αντικείμενο της εργασίας. Παρόλα αυτά ένα μεγάλο μείον ήταν η αργή εκτέλεση των προγραμμάτων. Θα ήταν καλύτερο σε μια μελλοντική υλοποίηση να γίνει χρήση C/C++ για γλώσσα προγραμματισμού.
  
Κάτι το οποίο δεν μελετήσαμε ήταν το να γίνει προεπεξεργασία του .wav αρχείου προτού το μετατρέψουμε σε pitch vector. Ίσως αν "καθαρίζαμε" τα .wav αρχεία να παίρναμε καλύτερης ποιότητας pitch vectors και να είχαμε καλύτερα αποτελέσματα κατά την αντιστοίχιση των ακολουθιών. 

Όπως αναφέρθηκε και στην Περιγραφή της Υλοποίησης, κάναμε την παραδοχή οτι το query που δίνει ο χρήστης στο σύστημά μας είναι από την αρχή του τραγουδιού. Για να θεωρήσουμε όμως ότι δίνεται μια ολική λύση στο πρόβλημα του Query by Singing/Humming αυτή η παραδοχή δεν θα έπρεπε να είναι απαραίτητη.

Όπως πάλι αναφέρθηκε στην Περιγραφή της Υλοποίησης, η δημιουργία της βάσης δεδομένων με τα pitch vectors έγινε κάνοντας serialization numpy arrays με τη χρήση του pickle. Το pickle αν και είναι ιδιαίτερα βολικό, δεν είναι πολύ γρήγορο. Θα μπορούσαμε να πετύχουμε μια επιτάχυνση της δημιουργίας της βάσης δεδομένων και του "unpacking" των serialized δεδομένων αν είχαμε χρησιμοποιήσει serialization με JSON, π.χ. TinyDB \cite{tinydb} ή κάποια πιο εξεζητημένη λύση. Βέβαια τότε θα γινόταν και πιο πολύπλοκη η υλοποίηση της Βάσης Δεδομένων.

Κάποιες μικρές αυτοματοποιήσεις που θα έκαναν πιο εύκολο τον πειραματισμό με διαφορετικές μεθόδους προεπεξεργασίας είναι οι παρακάτω:
\begin{enumerate}
	\item Θα ήταν καλό να μπορούμε να επιλέγουμε ποια τμήματα του κώδικα της προεπεξεργασίας θέλουμε να τρέξουμε σε κάθε πείραμα μέσω ορισμάτων που θα δίνονται από τη γραμμή εντολών.
 	\item Το σύστημα καταγραφής θα μπορούσε να δημιουργεί ένα καινούριο log file για κάθε νέο πείραμα, στην αρχή του οποίου θα έγραφε με ποιες παραμέτρους προεπεξεργασίας εκτελέστηκε το πείραμα.
  \item Θα ήταν καλό επίσης να κρατάμε ακριβείς χρόνους εκτέλεσης για το κάθε πείραμα.
\end{enumerate}

\subsection{Υλοποίηση με LSH}
Όπως αναφέρθηκε στο \ref{sub:lsh} η εισαγωγή του αλγορίθμου LSH θα μπορούσε να βοηθήσει σε μια γρήγορη, "πρόχειρη" πρώτη απόρριψη ground truth vectors που έχουν μεγάλη απόσταση από το query.

Στα πλαίσια της εργασίας αναπτύχθηκε μια απλή υλοποίηση τέτοιου συστήματος η οποία όμως τελικά απορρίφθηκε.
Η λογική που ακολουθήθηκε ήταν ο περιορισμός του search space στα $N$ κοντινότερα διανύσματα πάνω στα οποία θα εκτελεστεί τελικά ο dtw αλγόριθμος.

Το μεγαλύτερο πρόβλημα που αντιμετωπίσθηκε ήταν η ανομοιομορφία στα μεγέθη των ground truth και query vectors.
Καθώς δεν βρέθηκε κάποια υλοποίηση LSH (ή άλλου locality-sensitive αλγόριθμου) που να μπορεί να λειτουργήσει με διανύσματα διαφορετικών μεγεθών όλα τα ground truth και query vectors έπρεπε να γίνουν ίδιου μεγέθους με τη διαγραφή στοιχείων ή με την προσθήκη μηδενικών.

Τελικά, η υλοποίηση δεν προσέφερε σημαντική χρονική βελτίωση (λόγω της μεθόδου δημιουργίας του index) και οδήγησε σε μείωση της ακρίβειας.

\subsection{Υλοποίηση με Τεχνικές Μηχανικής Εκμάθησης}
Η συγκεκριμένη υλοποίηση σίγουρα επιδέχεται βελτίωση σε πολλά στάδια, που όμως δε κρίθηκε απαραίτητο να γίνει στα πλαίσια του μαθήματος. 

Αρχικά, σε επίπεδο pre-proccessing, τα δείγματα που εισάγονται στο νευρωνικό δίκτυο που χρησιμοποιήσαμε θα μπορούσαν να περάσουν από μια διαδικασία αποθορυβοποίησης, διαλογής (\textit{garbage-in-garbage-out}), και άλλων διαδικασιών καθώς είναι αυτά που δημιουργούν τον κανόνα μάθησης.

Επίσης, σίγουρα καταλυτικός παράγοντας είναι και ο αριθμός των ίδιων των τραγουδιών, ο οποίος κρίθηκε πολύ μικρός για τη συγκεκριμένη εφαρμογή. 
Στο επίπεδο των features, μεγαλύτερη διάρκεια των τραγουδιών αλλά και άλλες μετρικές (π.χ. ενέργεια RMS) θα εξασφάλιζαν περισσότερα χαρακτηριστικά για να χρησιμοποιηθούν στην εκπαίδευση του νευρωνικού δικτύου.

Από πλευράς software, παρότι το Matlab R2015a \cite{matlab} ήταν αρκετά βολικό για γρήγορα υλοποίηση και παρατήρηση αποτελεσμάτων, ίσως μια άλλη γλώσσα (όπως python ή R) θα βοηθούσε στη γρήγορη επεξεργασία των δεδομένων και στην καλύτερη παραμετροποίηση των κανόνων εκπαίδευσης με αποτέλεσμα ενός καλύτερου μοντέλου.